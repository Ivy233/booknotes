# 程序的机器级表示
## 一些警告
由于涉及到比较底层的东西，请注意系统的内核安全。  
同时小心黑客的入侵。通过覆盖缓冲区之外的内容来修改函数的返回值是一种常见的方法，虽然有栈随机化，栈破坏检测和限制代码可执行区域来提升被破坏的要求，但是依旧存在攻破计算机的方法。
## 整数代码
### 寄存器
整数寄存器一共十六套，一套四个，分别对应64位，32位，16位，8位，低位寄存器能取出高位寄存器的低位字段。
64位寄存器|32位寄存器|16位寄存器|8位寄存器
:-------:|:--------:|:-------:|:------:
%rax|%eax|%ax|%al
%rbx|%ebx|%bx|%bl
%rcx|%ecx|%cx|%cl
%rdx|%edx|%dx|%dl
--|--|--|--
%rsi|%esi|%si|%sil
%rdi|%edi|%di|%dil
%rbp|%ebp|%bp|%bpl
%rsp|%esp|%sp|%spl
--|--|--|--
%r8|%r8d|%r8w|%r8b
%r9|%r9d|%r9w|%r9b
%r10|%r10d|%r10w|%r10b
%r11|%r11d|%r11w|%r11b
%r12|%r12d|%r12w|%r12b
%r13|%r13d|%r13w|%r13b
%r14|%r14d|%r14w|%r14b
%r15|%r15d|%r15w|%r15b
### 操作数类型
操作数有一种立即数，就是直接一个常量直接参与运算；一种直接访问寄存器；其他的若干种全部都是内存访问。
类型|类似表达|备注
:--:|:----:|:---:
立即数|$20|20表示一个内存位置而不是一个数
寄存器|%rsp
存储器|0x100|$0x100表示一个数而不是一个内存位置
存储器|(%rsp)|和%rsp不一样的是，设%rsp寄存器存放着值A，(%rsp)就是内存位置为A的东西
存储器|20(%rsp)|等价于%rsp存放的值+20 对应的位置。
存储器|(%rsp,%rax)|寻找内存位置为%rsp,%rax寄存器的和的地方存了什么值。
存储器|20(%rsp,%rax)
存储器|(,%rsp,2)|2只能被4,8,16之类的值代替
存储器|20(,%rsp,4)
存储器|(%rsp,%rax,16)
存储器|20(%rsp,%rax,16)
总的来说，一共只有三个指令，立即数($20)，寄存器(%rsp)和存储器20(%rsp,%rax,4)，存储器值为0的项可以省略，括号内三项都省略的时候省去括号。
## 整数指令
在介绍指令之前，有一些预先的定义需要处理。  
b:字节，w:字，l:双字，q:四字  
有个小技巧就是任何函数返回的值都存储在%rax。
### mov系列
mov系列除了cltq之外都带有两个参数A,B，都是从A发送到B，但是请注意：不能同时为内存位置  
例如movq $0x100 %rax
指令|效果|可支持后缀|特殊备注
:--:|:-----:|:-----:|:---:
mov S D|将S的内容覆盖D的低位|b/w/l/q|movl不同，会清空高位
movz S R|零扩展传送，S->R|bw/bl/wl/bq/wq|匹配；R必须是寄存器
movs S R|符号扩展传送，S->R|bw/bl/wl/bq/wq/lq|同上
movasbq S R|向寄存器传送四字||mov最多只能传送32位立即数
cltq|只能将%eax符号扩展到%rax||编码紧凑
### 栈处理
任何代码需要的内存空间都有一个栈，用来存储需要的每一个变量。不过和熟知的不一样，栈是从内存位置大的位置到内存位置小的位置放置的，也就是说，栈顶的地址最低。  
警告：%rsp会随着栈的变化而同步更新。
指令|效果
:--:|:-----:
pushq S|向栈中压入一个四字数S，$\%rsp-=8$
popq D|向栈中取出一个四字数，放置到D，$\%rsp+=8$
### 算术运算
算术运算是相当大的一类指令，即使把后缀省略也有很多内容。  
由于支持后缀大多都是四类，所以如果不写都是b/l/w/q，即8位，16位，32位，64位。
指令|效果|特殊备注
:--:|:-----:|:-----:|:---:
leaq S D|计算S的地址，放置到D|可以用来加速寄存器运算<br>指针运算只能以q结尾
inc D|D++|
dec D|D--|
neg D|D=-D|
not D|D=~D|
add S D|D+=S|注意不是三个数
sub S D|D-=S|
imul S D|D*=S|有符号全乘法
xor S D|D^=S|
or S D|D\|=S|
and S D|D&=S
sal k D|D<<=k
shl k D|D<<=k|和上面是一样的
sar k D|D>>=k|算术右移
shr k D|D>>>=k(java)|逻辑右移
idivq S|%rdx=(%rdx:%rax)%S<br>%rax=(%rdx:%rax)/S|(%rdx:%rax)是将两者连接起来<br>64位运算只能为q
divq S|%rdx=(%rdx:%rax)%S<br>%rax=(%rdx:%rax)/S|只能为q|(%rdx:%rax)是将两者连接起来<br>64位运算只能为q
clto|(%rdx:%rax)=符号扩展(%rax)|转换为八字
imulq S|(%rdx:%rax)=%rax*S|有符号全乘法
mulq S|(%rdx:%rax)=%rax*S|无符号全乘法
### 比较与跳转
比较是基于四种类型的，分别是：$CF:无符号溢出，ZF:结果为0，SF:结果为负数，OF:有符号溢出。通过比较和set系列指令统一设定条件码。$  如果有四种后缀可以适配，则省略。
指令|效果|特殊备注
:--:|:-----:|:-----:
cmp S1,S2|按照S2-S1来计算条件码
test S1,S2|按照S2&S1来计算条件码
sete D|D=ZF|相等于0
setne D|D=~ZF|不等于0
sets D|D=SF|负数
setns D|D=~SF|非负数
setg D|D=~(SF^OF)&~ZF|有符号>
setge D|D=~(SF^OF)|有符号>=
setl D|D=SF^OF|有符号<
setle D|D=(SF^OF)|ZF|有符号<=
seta D|D=~CF&~ZF|无符号>
setae D|D=~CF|无符号>=
setb D|D=CF|无符号<
setbe D|D=CF|ZF|无符号<=
跳转有大部分是基于比较的，如果比较成立，则发生跳转。在后面会学习到CPU会对这种东西进行预判，如果正确将会大幅度加速程序，反之会有很大的惩罚。  
jmp系列都可以跳转到标注的地方（这是为了方便看懂的需要），实际的二进制代码是会跳转到某个内存位置。
指令|特殊备注
:--:|:-----:
jmp L|无条件跳转
je L|等于0发生跳转
jne L|不为0发生跳转
js L|负数时发生跳转
jns L|非负数发生跳转
jg L|有符号大于时发生跳转
jge L|有符号大于等于时发生跳转
jl L|有符号小于
jle L|有符号小于等于
ja L|无符号大于
jae L|无符号大于等于
jb L|无符号小于
jbe L|无符号小于等于
同时有了判定和跳转可以做到很多很实际的事情。  
但是直接跳转会造成极大的预测错误的性能耗费，因为要重建现场。所以有了条件传送指令，这不依赖于预测，能够把一个寄存器的东西放在另外一个寄存器里面。这种指令类似于C语言的?:表达式。但是只有当两个表达式很容易计算的时候（比如一个加法），才会进行条件传送。
指令|特殊备注
:--:|:-----:
cmove S R|等于0
cmovne S R|不为0
cmovs S R|负数
cmovns S R|非负数
cmovg S R|有符号大于
cmovge S R|有符号大于等于
cmovl S R|有符号小于
cmovle S R|有符号小于等于
cmova S R|无符号大于
cmovae S R|无符号大于等于
cmovb S R|无符号小于
cmovbe S R|无符号小于等于
## 结构体
在结构体之内有很多变量。一个结构体变量的所有内含量将会顺序存放在同一段内存中，并且会尝试进行4Byte对齐。如果一个char占据了一段4Byte的开头，之后跟了一个int变量，则两者之间的空间将被舍弃。所以说这会影响到占用内存和内存效率。  
如果代码中存在数组，系统会倾向于对齐，具体对齐是8bit还是4bit取决于数组类型。
## 浮点代码
浮点代码的寄存器有两类，一个是AVX的ymm寄存器，一共十六个，一个256位；一个是SSE的xmm寄存器，一共十六个，一个128位。其中%ymm0,%xmm0是固定的函数返回值，%ymm1~%ymm8,%xmm1~%xmm8都是传入参数。
## 浮点指令
在浮点指令中，为表述方便，不如使用代号：X代表xmm寄存器，M代表内存，R表示寄存器，后面跟着32或64表示位数。
### 浮点mov系列
指令|特殊备注
:--:|:-----:
vmovss M32 X/X M32|传送单精度数
vmovsd M64 X/X M64|传送双精度精度数
vmovaps X X|传送对齐好的单精度数
vmovaps X X|传送对齐好的双精度数
### 浮点转换系列
指令|特殊备注
:--:|:-----:
vcvttss2si X/M32 R32|截断，单精度数转换成整数
vcvttsd2si X/M64 R32|截断，双精度数转换成整数
vcvttss2siq X/M32 R64|截断，单精度数转换成64bit整数
vcvttsd2siq X/M64 R64|截断，双精度数转换成64bit整数
vcvtsi2ss M32/R32 X X|一般第二个和第三个相同以保留高位，整数转换成单精度数
vcvtsi2sd M32/R32 X X|一般第二个和第三个相同以保留高位，整数转换成双精度数
vcvtsi2ssq M32/R32 X X|一般第二个和第三个相同以保留高位，64bit整数转换成单精度数
vcvtsi2sdq M32/R32 X X|一般第二个和第三个相同以保留高位，64bit整数转换成双精度数
但是通常请注意：将float转换成都变了double一般会使用这个代码
```
vunpcklps %xmm0 %xmm0 %xmm0
vcvtps2pd %xmm0 %xmm0
```
核心原理是交叉存储，如果原始寄存器是[x3,x2,x1,x0]，则第一行之后这个寄存器会变成[x1,x1,x0,x0]，之后第二行会double化。
### 浮点运算
在这里最多有两个参数传入和一个传出。如果是双操作数，则只有一个操作数传入。传出保证是一个  
只有第一个数能够从内存中读取，其他的必须是XMM寄存器  
这里的所有指令都满足-s结尾为单精度运算，-d结尾为双精度运算。
指令|特殊备注
:--:|:-----:
vaddss/vaddsd|加法
vsubss/vsubsd|减法
vmulss/vmulsd|乘法
vdivss/vdivsd|除法
vmaxss/vmaxsd|求最大
vminss/vminsd|求最小
vsqrtss/vsqrtsd|求开方
浮点数同样也支持二进制运算，这些都是xmm寄存器的输入和输出
指令|特殊备注
:--:|:-----:
vxorps/vorpd|异或
vandps/andpd|与
浮点比较操作(AVX2)提供了两个浮点比较的指令。
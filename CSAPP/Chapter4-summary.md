# 处理器体系结构
### 4.1
相对于x86-64架构，为了方便实现，本书采用了一个y86-64架构，这个架构维持了大部分对比架构的特性，但是也有很大的变化。

寄存器只有64位的，而且缺少了%r15。这就带来了操作指令变化的大幅减少。  
寄存器只有15个，那么使用0xF代表不存在的位置（空位置）。  
在任何运算过程中都会设置条件码，这样省去了testq和cmpq的麻烦。  
同时指令类型也有大幅度变化：
指令|字节码
:--:|:-----:
halt|0x00
nop|0x10
rrmovq|0x20(rA-4bit)(rB-4bit)
irmovq|0x30F(rB-4bit)(val-64bit)
rmmovq|0x40(rA-4bit)(rB-4bit)(delta-64bit)
mrmovq|0x40(rA-4bit)(rB-4bit)(delta-64bit)
OPq|0x6(fn-4bit)(rA-4bit)(rB-4bit)
jXX|0x7(fn-4bit)(Dest-64bit)
cmovXX|0x2(fn-4bit)(rA-4bit)(rB-4bit)
call|0x80(Dest-64bit)
ret|0x90
pushq|0xA0(rA-4bit)F
popq|0xB0(rB-4bit)F
有个很值得探讨的问题：pushq %rsp这个指令放进去栈的是原值还是减4以后的值？
### 4.2
关于HCL表达式，需要注意的是尽可能少的比较，因为通过已知的比较可以省去很多不必要的信息。

寄存器存储的原理：存在一个信号的周期函数，当信号从0->1的时候，将新的数值拷贝到寄存器里面。

一个典型的寄存器有两个读一个写，顺带一个时钟输入。在要求读取的时候，src输入一个4bit二进制，返回其中的值；在写入的时候，输入val，在信号特定0->1的时候成功写入。

相反内存只有一个读，且具有一定的延迟，如果地址超过范围，那么在这玩意上面的error会被设置成1。
### 4.3
每一个y86-64指令都会经过六个阶段：取指，译码，执行，访存，写回，更新PC。  
其中大部分必须要寻找另外的临时变量来存储中间值。新的指令码默认是这条指令读取完成以后的第一个字节，不过有可能会被更改。 
阅读指令码的时候要注意，寄存器只是一个位置，要获取其中的值要再读取一次。

处理器有一个原则：从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。

SEQ可以说是HCL和前面讲述内容的集大成者，CS:APP以图示的方式来说明每一步是怎么完成的，这一块简单看看就好。
### 4.4
计算机中最优秀的设计就是流水线：将一个比较大的工程按照顺序分离，并尽可能按时间等分过程。换句话说，就是并行。  
但是仅此还不够。4.5.1讲述了SEQ+，就是流水线重新安排；4.5.3进行了指令重排；4.5.4进行下一个PC的预测，这个和第五章的分支预测有关，如果预测成功，将会大幅度压缩时间；如果预测太过危险，会通过一些方式来避免。
### 4.5
实际的实现又和预测的不太一样。

真实情况下将SEQ的PC计算挪到最前面(SEQ+)。  
同时加入了流水线寄存器，重新排列信号，得到PIPE-处理器。  
下一个PC判断预测。  
流水线冒险——并行处理会造成麻烦，如果发生了在上一条指令写回之前下一条指令用上了这个数就极为尴尬。
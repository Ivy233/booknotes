<style>
p{
    text-indent:2em;
}
</style>
# 让自己习惯C++
## Item 1 视C++为一个语言联邦
众所周知，C++是一门~~可以~~无法精通的语言，这门语言同时支持面向过程，面向对象，函数式编程，泛型以及元编程的形式，而这些组合起来其实没有这么多，一共就四种语言形式。

+ C
+ OO C++
+ Template C++
+ STL

但是神奇的是这些"语言"在相互切换的时候大部分规则都是适用的，或者只需要做出少量变化即可。而这些变化的核心只有一个：解决程序的二义性和明确调用的函数/方法是哪一个。
## Item 2 尽量以const, enum, inline替换 #define
### 导致无法预料的输出，甚至原因也无法预料
#define的形式大致如下
```C++
#define pi acos(-1)
#define f(x) ((x)*(x))
#define f(x) (x*x)
#define e 2.71828
```
大致常用的就这些形式把。但是一定要注意第二个和第三个的区别，如果你想调用
```C++
f(2*x+5)
```
在2-3行解释就是
```C++
f(x) => ((2*x+5)*(2*x+5))
f(x) => (2*x+5*2*x+5)
```
这直接造成了语义上的不同，而且这是在料想之外的。

就算是按照第二行来定义你期望的函数，也有可能会按照奇怪的形式运行，比如
```C++
f(x++) => ((x++)*(x++))
f(++x) => ((++x)*(++x))
```
请问这两个函数的输出会是什么？你可能在一个编译器中得到一个答案，在另外一个编译器中得到另外一个答案；也有可能在两个编译器中得到同一个答案，但是和你预计的不太一样。使用#define也有很多不可预料的行为。如果说这个例子还不足够说服你，那么我们再来看一个例子：
>取材自侯捷翻译的Effective C++ 3rd Edition
>```C++
>#define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
>int a = 5, b = 0;
>CALL_WITH_MAX(++a,b);
>CALL_WITH_MAX(++a,b+10);
>```

仔细观察就可以知道，传入f的参数具体大小甚至会因为比较结果而改变。第一个调用只++a了一次，但是第二个则是两次。
对于这种问题，最好的解决办法就是包装成一个函数。
```C++
template<class T>
inline T f(const T& x)
{
    return x * x;
}
```
在传入++x的时候，肯定是会先完成加法以后再进入函数，++x也是如此。
### 出错时很难查找原因
#define会在预处理期完成替换，从而把换掉的东西当成一个常量（函数太危险了）来完成计算。如果说这个时候出现了一个template导致类型不匹配，你去哪里查错？特别是在多人开发的时候，你对於这个常量从哪里来的都毫无头绪。所以这个时候建议使用const替换，关于const的指针，会在Item 3中讲解。

在类中有加入const，在每生成一个对象的同时也会产生一个const成员，并且在初次使用时初始化。这个时候就有可能const起不到const的作用，因为每一个类对象的同一个const成员含有不同的值。除非这是你期望的，否则建议你在const成员上加入static，并且在类生成的代码后面加入初始化，就像这样。
```C++
class Int
{
    static const int num = 5;   //只有int有可能可以在内部初始化
    static const double a;      //但是还是建议采用这一行表述方式
}
Int::a = 1.35;                  //在这里初始化
```
如果不允许在类内初始化static const int，并且需要用这玩意定义数组（只在STL的内存分配器中见过）的时候，建议采用enum来定义这个static const int。而且顺带提一句，enum变量取不出地址（笑）。
## Item 3 尽可能使用const
const的用法应该基本熟悉，赋值以后不允许改变。对于指针而言则有几种：

+ int *a;               //指针
+ const int *a;         //指针指向的值不可以改，但是可以改变指针指向哪里
+ int *const a;         //指针指向不可以改，但是可以改变指向的值
+ const int *const a;   //两个都不可以改


## Item 4 确定对象被使用前已先被初始化
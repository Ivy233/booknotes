# 第四章 网络层

这一章主要解决网络互连问题。本章最重要的内容是：

+ 虚拟互连网络的概念。
+ IP地址与物理地址的关系。
+ 传统的分类的IP地址和无分类域间路由选择CIDR。
+ 路由选择协议的工作原理。

## 网络层提供的两种服务

在IP和路由这两个概念诞生之前（或者和这两个概念没有什么关系），数据应该如何传送出去？

+ 在创建的时候需要**预先进行通道的分配**，这是**面向连接**的。专有的通道意味着**可靠交付**，再加上可靠的网络协议，就可以保证数据无差错，无丢失，无重复地达到终点。这种被称为**虚电路服务**。
+ 把数据切片最小化成分组独立发送，只**提供简单灵活、无连接的、尽最大努力交付的数据报服务**。这种方式不提供服务质量的承诺，因为有可能出错、丢失、重复或者失序错误。

一开始对于电信网络选择的是虚电路服务，因为这种方式考虑到了电话这种非智能设备的处理能力和设备的使用情景：**低处理能力，高可靠性要求**，因此只能选择由电信网络来处理这个信号传输。计算机网络尝试复制但是始终无法推广，直到发现了数据报服务，充分考虑到了计算机强大的处理能力，对于可靠性的要求没有这么高，甚至错误顺序可以重排。互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。

![4.1 网络层提供的两种服务](png/4.1 网络层提供的两种服务.png)

## 网际协议IP

网际协议IP是TCP/IP体系中最主要的两个协议之一，也是最重要的互联网标准协议之一。网际协议IP又称为Kahn-Cerf协议，是因为这两个人共同研发的这个玩意，而我们所称的**IPv4和v6**是第四个版本和第六个版本，也就是说1\~3和版本5都没使用过。

与IP配套的还有三个协议：

+ ARP协议，也是**地址嵌套协议**。
+ ICMP协议，也就是**网际控制报文协议**。
+ IGMP协议，也就是**网际组管理协议**。

其中ARP协议需要被IP调用，而ICMP和IGMP主要是调用IP协议。而网络层常被称为网际层或者IP层，这也强调了IP的重要性和这是由很多网络构成的互联网络。

### 虚拟互连网络

第二章讲解的是如何把01比特流发到其他地方，第三章讲解的是从数据链路层来看数据的传输，并且引入了物理地址和交换机，解释了点对点传输和碰撞。在[Wikipedia](https://zh.wikipedia.org/wiki/数据链路层)中指明了

>在两个网络实体之间提供数据链路连接的创建、维持和释放管理。构成数据链路数据单元（frame：[数据帧](https://zh.wikipedia.org/wiki/數據幀)或[帧](https://zh.wikipedia.org/wiki/訊框)），并对帧定界、同步、收发顺序的控制。传输过程中的[网络流量控制](https://zh.wikipedia.org/wiki/網路流量控制)、差错检测和差错控制等方面。
>
>只提供导线的一端到另一端的数据传输。

由于在一个局域网中，可以考虑仅仅使用点对点传输+广播来处理基本所有的需求，但是一旦网络变得很大，那么交换机内部存放的条目是不可接受的，因此需要分配子网络。而且用户需求的网络多种多样，加上商业竞争的存在，这些子网络之间必然会有差异，比如

+ 虽然以太网的名气非常巨大，但是不一定是唯一的一种网络，MAC这个说法在以太网中（802.x）存在，在比如说4G，5G这类的移动网络中是不存在的。
+ 智能家居中Zigbee和蓝牙、Wi-Fi连接的差异，这在米家中经常看到。

在不同的网络层次，很显然会有不同的连接方式。

+ 在物理层使用的叫做**转发器或集线器**。
+ 在数据链路层使用的叫做**网桥或交换机**。
+ 在网络层使用的叫做**路由器**。
+ 网桥和路由的混合物叫做**桥路器**。
+ 在网络层以上使用的叫做**网关**。
+ 当然有很多TCP/IP的文献把路由器当网关用了。

虚拟互连网络就是逻辑互连网络，它承认网络之间的差异，但是在兼容的协议下可以被认为是一种统一的网络。于是使用IP协议构造出来的叫做**IP网**。而**互联网也就是在覆盖全球的IP网上面走TCP协议**。

在这样的网络下，看上去一个主机可以和另一个主机能直接联络，实际上这在没有转发的情况下是不可能实现的。也正是因此，存在**直接交付**和**间接交付**两种说法，具体在什么情况发生顾名思义即可。最后采用原书中的一幅图来配套解释。

![分组在互联网中的传递](png\4.2.1 分组在互联网中的传递.png)

看到这里你可能会提出一些问题：

+ 这个路由表是怎么来的，如何使用？这个问题要到比较靠后才会解答，因此可以先假设这个网络已经比较稳定，即路由表可以获得一个比较好的结果，但是不一定能获得最优解。
+ 在本章和之前的知识中，MAC是数据链路层的东西，IP是IP层的东西，我们已经解释了在MAC上为什么还有一个IP，但是如何合理搭配使用两者及其算法才可以完成传送的任务？

### 分类的IP地址

在你对于IP网络没有什么了解的时候，建议对于IP的分类方法进行一个较为详细的了解，因为这一部分比较简单，而且到后面内容真正开始多起来的时候再去了解比较容易乱套。有关IP的文档最重要的就是RFC 791。

IP地址现在由**互联网名字和数字分配机构ICANN**进行分配，每一个IP地址就是给每个连在互联网上的主机分配一个在全世界范围内统一的32位标识符。IP编址方法经历了三个历史阶段。

+ **分类的IP地址**。这是两级IP，在这一块会有讲解。1981年通过。
+ **子网的划分**。这是三级的IP，在下一部分会有讲解。标准写进了RFC 950中，1985年通过。
+ **CIDR（超网）**。这是无分级IP，和子网划分会有讲解。1993年提出以后很快应用。



分类的IP地址分为两段，第一段是**网络号**，第二段是**主机号**，两者拼接即成32位，并且被分为了五类。

+ A类地址，二进制0开头，网络号占据8位，主机号占据24位。单播地址。
+ B类地址，二进制10开头，网络号占据16位，主机号占据16位。单播地址。
+ C类地址，二进制110开头，网络号占据24位，主机号占据8位。单播地址。
+ D类地址，二进制1110开头，作为多播地址。多播地址。
+ E类地址，二进制1111开头，保留。

IP的表示方法则主要由两种，一种是对于人而言比较好记忆的**点分十进制**，比如8.8.8.8，一种是对于计算机而言比较好计算的二进制，8bit一分，一共32bit。

不过要注意的是，在所有IP中有一些是不建议使用的，具体见下表。

| 网络号 | 主机号         | 源地址使用 | 目的地址使用 | 代表的意思                               |
| ------ | -------------- | ---------- | ------------ | ---------------------------------------- |
| 0      | 0              | 可以       | 不可以       | 本网络上的本主机                         |
| 0      | host-id        | 可以       | 不可以       | 在本网络上的某台主机host-id              |
| 全1    | 全1            | 不可以     | 可以         | 只在本网络上进行广播（各路由器都不转发） |
| net-id | 全1            | 不可以     | 可以         | 对net-id上的所有主机进行广播             |
| 0x7f   | 不是全0或者全1 | 可以       | 可以         | 用于本地软件进行环回测试                 |

因为有这些的影响，会导致ABC网络的网络号或者网络主机数目的减少，具体的就是：

| 网络类别 | 最大可指派网络数 | 第一个  | 最后一个    |
| :------- | ---------------- | ------- | ----------- |
| A        | 126              | 1       | 126         |
| B        | $2^{16-2}-1 $    | 128.1   | 191.255     |
| C        | $2^{24-3}-1 $    | 192.0.1 | 223.255.255 |

对于IP则应当由如下的特点：

+ IP是一个分等级的地址结构。在一定程度上，IP地址管理机构不需要具体到每一个IP的管理，只需要注意网络号的分配即可。而且路由器可以通过网络号来转发分组，这对于寸土寸金的路由器而言是必须要有的。
+ 实际上IP地址是标志一个主机（或路由器）和一条链路的接口。如果一个主机在两个网络上，就必须要有两个对应的IP地址，称之为**多归属主机**。显然一个路由器应当至少有两个IP地址，实际上，一个路由的每一个接口都有一个IP。
+ 在IP的视角下，用**转发器或网桥连接起来的网络还是一个网络**，因为网络号是一样的。连接不同的网络号就必须要使用路由器。
+ 所有分配到网络号的网络是**平等**的。
+ 两个路由器直接相连时，在连线两端的接口处，可以指明也可以不指明IP地址。

### IP地址与硬件地址

这里将会解答一个问题的一部分：

> 在本章和之前的知识中，MAC是数据链路层的东西，IP是IP层的东西，我们已经解释了在MAC上为什么还有一个IP，但是如何合理搭配使用两者及其算法才可以完成传送的任务？

MAC被称为**硬件地址**（物理地址），主要是因为在出厂时就被写入到网卡的ROM中。而IP与之对应的就成为了**逻辑地址**，因为IP是使用软件实现的。同时MAC和IP负责的主要位置有所不同：MAC负责链路层和物理层，而IP则是网络层以上。

在处理的时候，IP是不会变的（除了NAT以外），而MAC经过一个路由器就会改变一次，改成什么东西则取决于路由表和终点IP。在这一段中，有几点需要解释一下：

+ MAC仅记录了**当前节点和下一步**应该去往哪里，而IP记录了发送数据的**源和目的地址**。
+ MAC一直在变化，对应了数据链路层的PPP(oE)协议。

![4.2.3 IP和MAC的根本区别](png/4.2.3 IP和MAC的根本区别.png)

这里千万要注意这一些内容，因为这有可能会影响计算机网络的理解，而且和书上讲的不是一样的：

+ IP层屏蔽了IP层以下的内容。虽然书上只是讲解了802.3，也就是以太网、有线连接，但是实际上数据链路层还有很多其他的实现，**有可能某种实现方式没有MAC这种说法（比如4G，5G），也有的可能会使用到（比如802.11）**。因此IP层必须要有自己的一种定址方式。
+ IP的定址方式应该在一个足够大的网络环境下能比较方便定位到子网络，换句话说，IP地址完成了一个重要的任务：**IP到MAC的映射**。因为每一个用户买的设备基本不可能所有的设备都是一个东西。
+ 在一个网络足够复杂的时候，仅仅使用交换机必然会带来广播风暴，这不是仅仅依靠VLAN能解决的事情。

讲解到这里，我们尝试解决了一个问题的一部分，了解了IP层的大致工作方式，你有可能会提出以下问题：

+ 这个路由表是怎么来的，如何使用？这个问题要到比较靠后才会解答，因此可以先假设这个网络已经比较稳定，即路由表可以获得一个比较好的结果，但是不一定能获得最优解。
+ 在本章和之前的知识中，如何合理搭配使用两者及其算法才可以完成传送的任务？
+ 在传送IP数据报的时候，需要知道四个东西，分别是本机和目的地址的IP，和本机和下一站的MAC。在假设路由表是比较稳定的情况下，下一站的MAC是不了解的，这个怎么回答？

### 地址解析协议ARP

这里将会解答一个问题：

> 在传送IP数据报的时候，需要知道四个东西，分别是本机和目的地址的IP，和本机和下一站的MAC。在假设路由表是比较稳定的情况下，下一站的MAC是不了解的，这个怎么回答？

顺便提一句，ARP协议是从IP找到了MAC，同样也有RARP完成反操作，只不过有DHCP协议能完成上述这一点就没有讲解。而且ARP在IPv6中被NDP取代了。

ARP完成了这样的事情：

+ 在本局域网广播一个ARP请求分组，用中文的解释是“我，IP多少，MAC多少，想知道IP位xx的MAC”。
+ 本局域网上的所有主机的ARP进程都收到了这一个ARP请求。
+ 其中某主机B的IP和请求的IP是一样的，于是回送ARP请求，叫做ARP响应分组，是单播的方式。用中文解释就是“我IP多少，MAC多少”。
+ 注意一点：ARP只在局域网广播，过不了路由器。

但是有两个问题：

+ 不能总是没发一个IP就要一个ARP啊，真·烧流量。
+ 不在局域网该怎么办？

对于第一个问题，加一个缓存就可以了，叫做ARP高速缓存。每次开机的时候ARP高速缓存是空的。当然缓存的每一条都需要记录IP和MAC，这可以使用`arp -a`来查看。除此以外，每条记录都有一个生存时间，时间一到这一条就失效了。而且一般来说，在收到ARP报文之后，双方都会增加一条ARP条目。

ARP高速缓存大概长这个样子：

| 主机名称 |    IP地址     |      MAC地址      |
| :------: | :-----------: | :---------------: |
|    A     | 192.168.38.10 | 00-AA-00-62-D2-02 |
|    B     | 192.168.38.11 | 00-BB-00-62-C2-02 |
|   ...    |      ...      |        ...        |

至于第二个问题嘛~肯定是有解决方法的，下面是ARP的四个典型情况：

+ 发送方($H_1$)和接收方($H_2$)在同一个局域网下，这个时候就由$H_1$发送ARP分组，$H_2$接收以后发送回应即可。
+ 发送方($H_1 $)和接收方($H_3$)不在一个局域网下，那么同样$H_1 $发送ARP，返回的是$R_1$的MAC地址。
+ 发送方是一个路由器($R_1 $)，接收方是主机($H_2 $)，那么直接发送ARP便是。
+ 发送方和接收方都是路由器($R_1,H_4$)，那么则会返回$R_2 $的MAC。

![4.2.4 ARP的四种情况](png/4.2.4 ARP的四种情况.png)

如何判断对方是一个路由器还是一个主机？如果网络号……好了接下来的故事你们自己编。

剩下的就是ARP的报文内容：

|   长度(位)   |       48       |      48      |   16   |    16    |    16    |      8       |      8       |   16   |     48     |     32     |      48      |      32      |
| :----------: | :------------: | :----------: | :----: | :------: | :------: | :----------: | :----------: | :----: | :--------: | :--------: | :----------: | :----------: |
| **数据类型** | 目标以太网地址 | 源以太网地址 | 帧类型 | 硬件类型 | 协议类型 | 硬件地址长度 | 协议地址长度 | 操作码 | 源硬件地址 | 源协议地址 | 目标硬件地址 | 目标协议地址 |

其中

+ 硬件类型：如以太网（0x0001）、[分组无线网](https://zh.wikipedia.org/wiki/封包無線電)。
+ 协议类型：如[网际协议](https://zh.wikipedia.org/wiki/网际协议)(IP)（0x0800）、[IPv6](https://zh.wikipedia.org/wiki/IPv6)（0x86DD）。
+ 操作码：1为ARP请求，2为ARP应答，3为[RARP](https://zh.wikipedia.org/wiki/逆地址解析协议)请求，4为RARP应答。

一直到这里，你有可能还有如下问题没有解决：

+ 这个路由表是怎么来的，如何使用？这个问题要到比较靠后才会解答，因此可以先假设这个网络已经比较稳定，即路由表可以获得一个比较好的结果，但是不一定能获得最优解。
+ 在本章和之前的知识中，如何合理搭配使用两者及其算法才可以完成传送的任务？

但是在解答这些问题之前，还是要介绍一下IP数据报的格式。

### IP数据报的格式

| 位偏移 | 0–3  |   4–7    |   8–15   | 16–31 |
| :----: | :--: | :------: | :------: | :---: |
|   0    | 版本 | 首部长度 | 区分服务 | 全长  |

| 位偏移 |  0–15  | 16-18 |  19-31   |
| :----: | :----: | :---: | :------: |
|   32   | 标识符 | 标志  | 分片偏移 |

| 位偏移 |   0–7    | 8-15 |   16-31    |
| :----: | :------: | :--: | :--------: |
|   64   | 存活时间 | 协议 | 首部检验和 |

| 位偏移 |   0–31   |   32-63    |    64+     | 64+  |
| :----: | :------: | :--------: | :--------: | :--: |
|   96   | 源IP地址 | 目的IP地址 | 可能的选项 | 数据 |

其中每一项的解释：

+ 版本：4bit，通信双方使用的版本必须一致。对于IPv4，字段的值是4。
+ 首部长度：4bit，首部长度说明首部有多少32位字（4字节）。由于IPv4首部可能包含数目不定的选项，这个字段也用来确定数据的偏移量。这个字段的最小值是5，相当于20字节，最大十进制值是15。
+ 区分服务：8bit，最初被定义为服务类型字段，实际上并未使用，但1998年被IETF重定义为区分服务。只有在使用区分服务时，这个字段才起作用，在一般的情况下都不使用这个字段。
+ 全长：16bit，定义了报文总长，包含首部和数据，单位为字节。这个字段的最小值是20（20字节首部+0字节数据），最大值是$2^{16}-1=65,535$。IP规定所有主机都必须支持最小576字节的报文，这是假定上层数据长度512字节，加上最长IP首部60字节，加上4字节富裕量，得出576字节，但大多数现代主机支持更大的报文。当下层的数据链路协议的**最大传输单元（MTU）**字段的值小于IP报文长度，报文就必须被分片。
+ 标识符：16bit，因为分片不一定按序到达，被用来唯一地标识一个报文的所有分片，在重组时需要知道分片所属的报文。每产生一个数据报，计数器加1，并赋值给此字段。一些实验性的工作建议将此字段用于其它目的，例如增加报文跟踪信息以协助探测伪造的源地址。
+ 标志：3bit，用于控制和识别分片，它们是：
  + 位0：保留，必须为0。
  + 位1：禁止分片（DF），当DF=0时才允许分片。如果DF标志被设置为1，但路由要求必须分片报文，此报文会被丢弃。这个标志可被用于发往没有能力组装分片的主机。
  + 位2：更多分片（MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。

- 分片偏移：13bit，指明了每个分片相对于原始报文开头的偏移量，以8字节作单位。
- 存活时间：8bit，避免报文在互联网中永远存在（例如陷入路由环路）。原本计划中是以秒为单位，每过1s就少1，到0的时候报文自动丢弃。
  - 在现实中，成了一个跳数计数器：报文经过的每个路由器都将此字段减1，当此字段等于0时，报文不再向下一跳传送并被丢弃，最大值是255。这主要原因是处理能力太大了，如果还是按照秒来计算可能要走过七位数的路由器，和环路有啥区别= =。
- 协议：8bit，这个字段定义了该报文数据区使用的协议。IANA维护着一份协议列表（最初由RFC 790定义），详细参见[IP协议号列表](https://zh.wikipedia.org/wiki/IP协议号列表)。
- 首部检验和：16bit，检验和字段**只对首部查错**，不包括数据部分。在每一跳，路由器都要**重新计算**出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。这种方式可以理解为如下两种，因为大部分计算都是异或。重新计算的必要性是因为每一跳的一些首部字段（如TTL、Flag、Offset等）都有可能发生变化，不检查数据部分是为了减少工作量。
  - 类似于产生首部校验和的方式一样，计算出来以后和检验结果进行比对。
  - 把首部校验和带入计算，此时计算出来的“首部校验和”为0。
- 源地址：32bit，注意：因为NAT的存在，这个地址并不总是报文的真实发送端，因此发往此地址的报文会被送往NAT设备，并由它被翻译为真实的地址。
- 目的地址：与源地址格式相同，但指出报文的接收端。

IP数据报在传入MAC分片的时候，首部数据会重复计算。比如一段4500Bytes的数据发到MTU=2500Bytes进行分片，那么会产生两个IP数据报：

1. 长度2500Bytes，其中首部20Bytes，数据2480Bytes，MF=1，DF=0。
2. 长度2040Bytes，其中首部20Bytes，数据2020Bytes，MF=0，DF=0。

### IP层转发分组的流程

这里将会解答两个问题。

> 在本章和之前的知识中，如何合理搭配使用两者及其算法才可以完成传送的任务？
>
> 路由表是什么东西？

首先解答一下第二个问题：路由表是一个记录从网络和下一跳操作的表格，比如：

![4.2.6 路由表举例](png/4.2.6 路由表举例.png)

当然有的时候不一定需要这么具体，还可以指定一个默认路由，就是如果不存在解答方式的话就按照这一条办。直接和默认路由这样的字样都会被记成0.0.0.0。

至于第一个问题则直接用算法描述就行了，两者的配合方式已经被ARP协议描述的非常清楚。

```mermaid
graph TD
A(等待数据包)-->|获取数据报|B(解析目的IP地址D和目的网络地址N)
B-->C(查询路由表分类讨论)
C-->|路由表中有D|D(直接交付)
C-->|反之|E(是否有网络号N)
E-->|如果有网络号N|F(交付给网络号N的网络)
E-->|反之|G(检查默认路由)
G-->|如果有默认路由|H(交给默认路由)
G-->|反之|I(查找失败 出错)
F-->J(结束)
D-->J
G-->J
H-->J
I-->J
J-->A
```

## 划分子网和构造超网

### 划分子网

之前的两级IP网络十分不灵活，主要体现在了三点：

+ IP地址空间利用率低。一个A类地址有1kw地址，但是B类就只有六万左右，于是有的时候就有一个公司在者这之间的只能申请一个A类地址；也有的公司拿到了一个B类，但是不愿意只申请一个C类地址。
+ 给每一个物理网络分配一个网络号会让路由表太大导致网络性能变坏。
+ 时间上不够灵活，在新的IP产生的时候，如果情况紧急也无法从原本的大网络中分离出一个小网络来。

于是划分子网把原本二级网络的主机号分成子网号和主机号两个部分，在网络号的路由器收到IP数据报以后，会根据子网号发送给下一级或者直接传送出去，但是对外而言，还是要经过这一路由器，看不到内部的细节。

![4.3.1 划分子网](png/4.3.1 划分子网.png)

在分出子网以后，就需要子网掩码的来保证子网的隔离。子网掩码只有在高位为连续的1，在低位全部为连续的0，虽然这不是强制要求，但是RFC极力推荐子网掩码用连续的1。当然如果不划分子网掩码，那么就使用网络号自带的子网掩码。

划分子网用能连接在网络上的主机总数来换取划分子网的灵活性。

### 使用子网时分组的转发

这种分组算法和两级IP的分组转发是非常相似的，只不过把直接比较换成和子网掩码取位与之后进行比较。

1. 从数据报首部获取目的IP地址D。
2. 获取路由中每一项的网络号和子网掩码，计算与比较。下述选项分先后。
   1. 如果D和路由表中该行的子网掩码相与之后和某个子网号相同则进行直接交付。
   2. 如果路由表中有目的地址为D的特定主机路由，则间接交付到下一跳路由。
   3. 如果路由表中该行的子网掩码和D相与之后和该行的网络地址相同，也间接交付给下一跳路由器。
3. 如果所有的路由项目都比较完了还是没传送出去，那么查看是否有默认路由，如果有就发出去。
4. 说明无法处理，报告转发出错。

同时要注意的是，每一台主机本身都存储了自己的子网掩码，也就是说，主机本身也有"路由器"的功能。

### 无分类编址CIDR（构造超网）

虽然划分子网能在一定程度上缓解了IPv4的难题，但是还是要面对地址空间耗尽的大问题。为此IETF首先推出了CIDR（无分类编址）来缓解单独一项被使用完毕的难题，同时联合各个AB类地址有多余地址空间的释放一些不需要的地址空间（比如很多美国大学在IPv4刚推出的时候就拿到了一个A类地址）和NAT技术以延缓使用完毕的时间。除此以外，成立IPv6工作组设计IPv6的标准来彻底解决地址耗尽的问题。

#### CIDR记法

CIDR消除了传统的网络类别和划分子网概念，转而使用网络前缀+主机号这种变长子网掩码VLSM的方式来完成网络编址，网络前缀长度即子网掩码的长度。由于子网掩码的歧义，需要一个数字来标定长度。

CIDR记法把网络前缀相同的连续IP地址组成了一个CIDR地址块。由于一个CIDR地址块中有很多地址，所以路由表中就利用CIDR地址块来查找目的网络，这种地址的聚合称为路由聚合，可以用一个项目表示原来分类方法下的很多个路由（CCF出过这一类题目）。路由聚合也成为构造超网。

这种分类方法在三级IP的前提下极大减少了路由表中的地址数量，也极大提升了灵活性，甚至可以在一个CIDR下进行更多子网的分配和不同大小子网的分配。

#### 最长前缀匹配

在CIDR记法下，有可能在一个路由表中会找到多条符合条件的路由项，这个时候就会选择最长子网掩码的匹配，主要原因：

+ 越长的子网掩码代表了越小的网络，这意味着网络更具体。
+ 很大的子网掩码有可能是小网络合并而来。
+ 在这种规定下，可以很省事的继续压缩路由表，人为的把冲突消除（而不是逻辑上消除冲突）。

## 网际控制报文协议ICMP

ICMP协议是互联网协议族的核心协议之一。它用于网际协议中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。

ICMP依靠IP来完成它的任务，它是IP的主要部分。但是ICMP不是IP的高层协议，而是和IP同级，这是因为它与传输协议显著不同：它一般不用于在两点间传输数据。除了在ping和traceroute以外没有被网络程序直接使用。在IPv4中的ICMP被称为ICMPv4，ICMPv6则被用于IPv6。

### ICMP报文的种类

ICMP报文是写在IP数据报中的数据部分中，但是ICMP报文通常来说会进行特别处理。

+ TTL归0就是ICMP的一种报错方式，而且会从TTL归0的地方开始回报错误信息。

|  Bits   | 0-7  | 8-15 |       16-31        | 32-63 | 64-95 |
| :-----: | :--: | :--: | :----------------: | :---: | :---: |
| **160** | Type | Code | 校验码（checksum） |  ID   | 序号  |

这仅仅是ICMP报文的报头，后续还会跟着一些数据。

+ Type是ICMP报文的类型。
+ Code是ICMP报文类型下的代码，作为Type的子类型来查找错误原因。
+ 校验码进检查ICMP报头和数据部分。
+ ID和序号在Echo Reply中要返回。Echo Reply是Type和Code都为0的情况。

具体返回值和代码在[ICMP](https://zh.wikipedia.org/wiki/互联网控制消息协议)中找到。其中最常见的就只有几种：


|      类型       | 代码 |                             描述                             | 查询 | 差错 |
| :-------------: | :--: | :----------------------------------------------------------: | :--: | :--: |
| 0 - Echo Reply  |  0   | echo响应 (被程序[ping](https://zh.wikipedia.org/wiki/Ping)使用） |  ●   |      |
| 3 - 目的不可达  | 0-15 |                                                              |      |  ●   |
|   5 - 重定向    | 0-3  |                                                              |      |  ●   |
|  8 - 请求回显   |  0   |                           Echo请求                           |  ●   |      |
|  11 - ICMP超时  | 0-1  |                     TTL或者分片重组超时                      |      |  ●   |
|  12 - 参数问题  | 0-2  |           首部参数错误，丢失必要选项，不支持的长度           |      |  ●   |
| 13 - 时间戳请求 |  0   |                                                              |  ●   |      |
| 14 - 时间戳应答 |  0   |                                                              |  ●   |      |

## 互联网的路由选择协议

这里将会解答一个之前没有解决的问题：

>这个路由表是怎么来的？

### 有关路由选择的几个基本概念

路由表每一项的由来就是这个路由选择协议，通过及时的更新来跟随网络的变化而变化。自然，这个算法应该有如下的特性：

+ 算法必须是正确的和完整的。这里的正确指代沿着路由表指引的路由，分组一定能最终到达目的网络和目的主机，而不是一定要沿着最短路径。
+ 算法在计算上应当简单。路由器的性能不会太高，除了计算路由表以外，还要同时处理大量分组转发。
+ 算法应能适应通信量和网络拓扑的变化。
+ 算法应该是公平的，除了对于少数优先级特别高的用户以外，不应当为了少数群体的时延减小而忽略了其他。
+ 算法应该是最佳的。当然这里的最佳是在手上已有的信息里面选择最优结果，而不是全局最优。
+ 算法应该具有稳定性。这里指代的是在网络通信量和网络拓扑相对稳定时，路由算法应当收敛。

在算法的分类上，则是分为静态路由选择策略和动态路由选择策略两种。

+ 静态路由选择策略适合小网络，简单而且开销小，但是不能及时适应网络的变化。一种实现方式是人工配置路由。
+ 动态路由选择策略适合大网络，能较好适应网络的变化，但是实现起来较为复杂。



考虑到不同的企业/部门可能会有不同的打算，所以对于网络的要求会不一样，因此互联网被划分成了很多个比较小的自治系统，而路由选择则在自治系统之间和自治系统之内分别有时间，对应的协议则叫做内部网关协议IGP和外部网关协议EGP。当前的外部网关协议就是BGP。

### 内部网关协议RIP

#### 工作原理

RIP协议是一种非常简单的基于距离向量的路由选择协议，但是很少被使用。在这个协议中，距离被定义成了跳数，即经过的路由器数量。距离比较小的路由条目则被认为是好的路由条目，而时延这一类确实没有被纳入考虑。在这个协议中，距离到了16则被认为不可达，因此RIP只适合用于小型互联网。

RIP协议是一个分布式路由协议，要求路由器交换信息的方式是这样的：

+ 只和相邻路由交换信息。
+ 交换的信息是整个路由表，至于怎么处理则由算法决定。
+ 按照固定的时间间隔交换路由信息。

一开始路由器加入网络的时候，它的路由表就只有和它相邻的路由信息，一段时间以后，从其他人的路由信息表拿到的信息不断填充，RIP自带的算法也能收敛。

#### 距离向量的计算

路由器只接受相邻路由的发送信息，这意味着路由器不能对全图有一个非常细致的了解，只能基于已有的信息对于“下一步”进行一个讨论。

1. 对相邻的路由器发来的RIP报文，先修改报文的所有项目：距离+1，下一跳改为发来的路由器地址。
   + 每一条路由项都有三个内容：目的网络N，距离d和下一跳路由器X。
   + 对于直接相连的网络，距离一般定义为1，不过在同样增加的体系下，这个初始距离不影响比较，只会影响网络的最大容量。
2. 对修改后的RIP的每一个项目，进行分类讨论：
   + 若自己已有信息中没有目的网络N，那么添加进去。
   + 若已有目的网络N，而且下一跳路由器就是发来的地址，那么按照新的为准，替换。
   + 若已有目的网络N，下一跳路由器不是发来的地址，而且距离小于已知的距离，那么替换。
   + 其余则什么也不做。
3. 若3分钟还没有收到相邻路由器的路由更新表，把这个路由器标记为不可达路由，距离标记为16。
   + 这里的3分钟是相对于30s而言的，具体情况具体分析。
   + 距离标记为16代表着距离无限大。

#### RIP报文

RIP报文的具体信息则由一张图来表示（由于RIP一代报文已经基本不使用，所以使用RIP来指代RIP2。）

![4.5.2 RIP报文](png/4.5.2 RIP报文.png)

其中可以看出的是，RIP报文在UDP数据报中才经过IP包装发送出去。当然还是要解释一下可能不理解的地方。

+ 命令：报文的意义，1代表请求路由信息，2表示对请求路由的响应。
+ 这些命令考虑了4字节的对齐。
+ 没有使用CIDR的方式来标记IP地址，而是采用了IP+子网掩码的方式来发送路由信息。
+ 路由标记填入的是自治系统号ASN。
+ 地址族标识符填入使用的地址协议，这是因为RIP在设计的时候考虑了非TCP/IP的情况。

RIP协议自然存在一个问题，就是好消息传得快，而坏消息传得慢。在一个比较遥远的路由上拿到了自己出现故障的信息，但是同时也有相邻路由传过来的好路由的信息，这个时候根据RIP算法自然只能选择快的那一条。放在现实社会中自然也有这样的信息传递不方便的情况（古代社会）。与此同时，如果设计一条规则：

+ 如果网络不可达，那么直接录入。

这样会导致如果一个网络故障，那么很有可能无法再次进入，除非再新增一个字段。字段的增加有可能会不兼容。

在实际表现上，如果网络出现了故障，只有在出口路由不断等待其他路由器传回的报文才可以不断增大到16。

### 内部网关协议OSPF

这一段在课本上的表述始终有点不清不楚，所以这里大量采用了[wiki](https://zh.wikipedia.org/wiki/开放式最短路径优先)的内容。

RIP协议从字段上就不允许网络非常大，OSPF则在比较大的网络中常常出现。在实现上OSPF用更大的流量来交换更多的数据，尽可能抵消RIP协议的劣势。在讲解中我们选择了IPv4的OSPF v2[RFC 2328]，这和支持IPv6的OSPF v3[RFC 5340]还是有一点区别的，虽然区别不大。

OSPF的全称是开放式最短路径优先算法，开放是因为有很多个厂商控制这个协议，而最短路径优先则是采取了一种SPF算法的实现，即大名鼎鼎的Dijkstra算法。

#### 区域与路由器

OSPF提出了“区域（Area）”的概念，一个网络可以由单一区域或者多个区域组成。其中，一个特别的区域被称为骨干区域，该区域是整个OSPF网络的核心区域，并且所有其他的区域都与之直接连接。所有的内部路由都通过骨干区域传递到其他非骨干区域。所有的区域都必须直接连接到骨干区域，如果不能创建直接连接，可以通过虚链路和光驱与创建虚拟连接。

从前面可以了解到，OSPF采用了dijkstra算法，为了得到需要的数据，必须要获得整个网络的链路图。但是从一个点了解需要使用洪泛法（Floodfill），这对于不分区域的OSPF自治系统而言是不可接受的，因此才会有区域这个概念来进一步划分网络。Area的书写方法有两种：

+ Area 1.1.1.1：这是类似于IPv4的点分十进制记录方法，这四个数正好对应于IPv4的值。
+ Area 1：等价于Area 0.0.0.1。

对于路由器则有如下的划分，一个路由器可以被划分到下述几种的一种或多种。

+ 内部路由器。如果一台路由器上所有启用了OSPF的接口都在同一区域，那么这台路由器就是内部路由器。
+ 骨干路由器。骨干路由器是指至少有一个启用了OSPF的接口是和骨干区域（Area 0）相连的路由器。
+ 区域边界路由器。区域边界路由器是指连接一个或者多个区域的路由器。区域边界路由器为每一个与之相连的区域维护一份链路状态数据库，因此区域边界路由器需要比内部路由器更多的内存资源和更高性能的处理器。
+ 自治系统边界路由器。负责自治系统和自治系统之间的交互。

![4.5.3 OSPF的区域划分](png/4.5.3 OSPF的区域划分.png)

#### 交换

相对于RIP而言，OSPF传递的内容，时机和对象和RIP完全不一样。

+ OSPF向本自治系统里面的所有路由器发送信息，使用的方法是洪泛法（不知道的可以搜索floodfill）。
+ OSPF发送的信息是本路由器相邻的所有路由器的链路状态，这不仅仅包括三个字段，还包括很多其他方面，比如费用、距离、带宽、时延等等。衡量的角度一旦多样，判断规则也会复杂，但是灵活性将会大幅提升。
+ OSPF只有在链路状态发生变化时才会开始发送。这个和30s发送一次不一样，在有限的网络带宽中尽可能做有用的事情。

在OSPF中，最终得到的结果就是所有的路由器都能建立一个链路状态数据库，这个数据库实际上就是全网的拓扑结构图，并且能保持同步。都能建立全网的拓扑结构了，更新收敛肯定会非常快，实际上，这个数字应该在ms级别，而不是RIP的分钟级。

#### 报文

OSPF的数据报封装在IP数据报中，包括OSPF首部和OSPF分组两个部分。其中OSPF首部见下图。

![4.5.3 OSPF报文首部](png/4.5.3 OSPF报文首部.png)

其中有些内容可能需要解释：

| 字段         | 意义                                                   |
| ------------ | ------------------------------------------------------ |
| 版本         | 当前介绍的是OSPF v2，所以填入2，本身的含义是OSPF版本。 |
| 类型         | 当前版本的OSPF定义了五种分组类型。                     |
| 分组长度     | 包括了分组首部在内的长度，但是不包括IP数据报长度。     |
| 路由器标识符 | 发送给该分组的路由器的接口的IP地址。                   |
| 区域标识符   | 分组属于的区域的标识符。                               |
| 校验和       | 用于检验分组中的差错，OSPF报文全文检验。               |
| 鉴别类型     | 包含两种，0为不需要，1为口令检验。                     |
| 鉴别         | 鉴别类型为0时填入64个0，反之填入64bit的口令            |

而OSPF的报文有五种：

+ Hello报文，用于检验可达性。相邻站点必须10s相互发一次hello报文，如果超过40s都没有发送，那么认为这个路由不可达，并且更新，洪泛法走起。
+ 数据库描述分组，用于向邻站给出自己的链路状态数据库中所有链路项目的摘要信息。
+ 链路状态请求非组，向对方请求发送某些链路项目的详细信息。
+ 链路状态更新，用洪泛法对全网更新链路状态。
+ 链路状态确认，对链路状态更新报文的确认。

在两个路由相互联络时，需要进行不同的报文交换。

![4.5.3 OSPF基本操作](png/4.5.3 OSPF基本操作.png)

### 外部网关协议BGP

#### 使用BGP协议的原因

在自治系统内部，我们可以使用RIP和OSPF来完成自治系统内部分组的传递，并且找到从A到B的一条最短路径。但是在互联网中依旧采用了外部网关协议，主要是因为

+ 互联网的规模太大，使得自治系统AS之间的路由选择非常困难。虽然一个自治系统可以有比较大的数目，但是在互联网的主干路由器中，一个路由表的项目数是远远大于5w个网络前缀的。如果使用RIP显然不可行，但是OSPF时空复杂度都太大了。
+ AS对于代价的不同代表了无法使用统一的一种代价来计算链路的代价。因此只能在自治系统之间交换可达性信息，而不是代价信息。
+ 策略问题。有些信息不希望绕圈子，也有些信息我们是不希望经过某些地方。从OSPF和RIP的实现来看，只是实现了最优解，而没有考虑策略问题要求的灵活性。

在这三点上，我们不要求BGP给出一个最优解，而是给出一个在已知要求上的较优解。

每一个自治系统意图接入BGP网络，则需要选出至少一个BGP发言人（废话），BGP发言人通过一个共享网络链接在一起的，而BGP发言人往往就是BGP边界路由器，不过也有可能不是。当然，既然是从自治系统里面选出来的，自然也要运行自己的内部网关协议。

#### BGP协议的特点

BGP协议采用了路径向量路径选择协议，而且人为把整个互联网体系定义成了一个树，即

![1.2.2 多层结构互联网](png/1.2.2 多层结构互联网.png)

这下只要标记好父子关系即可模仿出整个树的样子，于是乎完成了整个树的访问。同样的，因为ISP的数目没有这么多，所以树的节点数是自治系统个数的量级，而且BGP发言人在自治系统里面也不是很多。

关于这一部分，留一个坑，在彻底了解BGP协议之后再回来填坑。

#### BGP报文

BGP报文一共有四种：

+ OPEN报文，用来和相邻的BGP发言人建立关系，使通信初始化。该报文有六个字段：版本（1字节，填入4），本自治系统号（2字节，使用全球唯一的自治系统号），保持时间（2字节，以秒为单位计算保持邻站关系的时间），BGP标识符（4字节，通常就是该路由器的IP），可选参数长度（1字节）和可选参数。
+ UPDATE报文，用来通告某一路由的信息，以及列出的要撤销的多条路由。注意，一条UPDATE报文中只能添加一条路由，但是可以删除多条。该报文共有五个字段，即不可行路由长度（2字节，指明下一个字段的长度），撤销的路由，路径属性总长度（2字节，指明下一个字段的长度），路径属性（增加的路径的属性），和网络层可达性信息NLRI（指明了自己所在网络的信息，包括前缀位数、IP前缀）。
+ KEEPALIVE报文，仅19字节长，用来周期性检验邻站的连通信。这也是BGP报文的通用首部。
+ NOTIFICATION报文，用来发送检测到的差错。该报文一共有三个字段：差错代码（1字节），差错子代码（1字节），差错数据（诊断信息）。

### 路由器的构成

#### 路由器的结构

> 路由器只包括了从物理层到网络层

路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。其中分组在经过输入端口输入以后经过路由表处理，交给输出端口转发出去，就完成了一个分组的任务。

路由器的结构可以分成两大部分：路由选择部分和分组转发部分。

路由选择部分也叫做控制部分，其核心构件是路由选择处理机，主要负责依据所选定的路由选择协议构造出路由表，以及保持路由表的同步。

分组转发部分则由三部分组成：交换结构，一组输入端口和一组输出端口。注意这里的路由器不包括无线的部分，不要和市面上出售的无线路由器混淆。当然为了不让交换结构和处理机本身的练习太多，每一个输入端口都有一个路由表的备份，称为影子副本。

同时在输入端口和输出端口的网络层区域都有一个队列用于缓冲，数据链路层和物理层的速度较快则没有处理。

+ 不过特别要注意的是，如果输入端口和输出端口的速度不匹配，则必然会导致某处的队列满载，进而导致网络阻塞，并且之后进入队列的所有分组丢失。为此在第五章里面有个建议：设置一个小于队列的阈值，超过以后则有一定概率随机抛弃分组，进而尽快触发分组传递的速度下降。

#### 交换结构

路由器的输入和输出通常由这三种方法来连接。

![4.5.6 路由器转发](png/4.5.6 路由器转发.png)

## IPv6

IPv6作为下一代的IP协议，解决的核心问题在于IPv4的地址耗尽，并且顺便针对其他层的协议进行一些改良。IPv6直接来了128位的IP地址，并且使用了新的表示方法和新的数据报。为了方便在IPv4上面流动，也使用一些方式来帮助完成IPv4到v6的过渡。

### IPv6的基本首部

IPv6主要是无连接的传送，但是将数据单元PDU称为分组，而不是IPv4的数据报，不过有很多时候两者是可以混用的。IPv6引进的主要变化如下，这些主要变化后面极有可能是没有提及的：

+ 改进的选项。
+ 允许协议继续扩充。
+ 支持自动配置。
+ 支持资源的预分配。
+ 改为8字节对齐。

IPv6数据报由两大部分组成，基本首部和有效载荷，其中扩展首部也放在有效载荷里面，基本首部只有40字节。IPv6的数据报格式就是

| 内容         | 位数   | 描述                                                         |
| ------------ | ------ | ------------------------------------------------------------ |
| 版本         | 4bit   | 协议版本6                                                    |
| 通信量类     | 8bit   | 区分不同的IPv6数据报的类别和优先级。目前正在进行不同的通信量类性能的实验 |
| 流标号       | 20bit  | 所有属于同一个流的数据报都有同样的流标号，主要用于实时音视频的传送，对于传统的电子邮件则直接写入0即可。 |
| 有效载荷长度 | 16bit  | 除基本首部以外的字节数，最大65535字节。                      |
| 下一个首部   | 8bit   | 相当于IPv4的协议字段或可选字段。                             |
| 跳数限制     | 8bit   | 类似于IPv4的TTL，每过一个路由器则-1，到0的时候就丢弃这个数据报。 |
| 源地址       | 128bit | 发送端的IP地址                                               |
| 目的地址     | 128bit | 接收端的IP地址                                               |

+ 如果IPv6没有扩展首部时，下一个首部字段的意义和IPv4的协议字段一样，它的值指出了基本首部后面的数据应交付IP层上面的高层协议。当出现扩展首部时，下一个首部字段应当是表示后面第一个扩展首部的类型。

IPv6对于路由器而言友好了很多，因为在大部分情况下路由器不需要计算即可直接转发。

+ 没有首部校验和，减少计算时间。
+ 大部分的扩展首部都不需要处理。

扩展首部的字段定义了的只有六种：逐跳选项；路由选择；分片；鉴别；封装有效安全载荷；目的站选项。所有扩展首部长度一般不一样，但是所有首部的第一个字段都是下一个首部，形成了链表的结构，而且最后一个的扩展首部的第一个字段就是高层协议。

### IPv6的地址

扩展到128位，那么地址写法就不太可能是点分十进制了，不然就像
$$
111.222.222.222.222.222.222.222.222.222...
$$
不是总是会知道有几个小数点，为此为了方便记录采用了冒号十六进制记法，即$1111:1111:1111::$，而且由一些可以省略的规则：

+ 可以省略两个冒号之间四个十六进制的前导0。
+ 可以把一连串的0换成两个冒号以省略长度，但是一个地址只能压缩一次，压缩方式可以任意选择。

并且把IPv6分为以下五类地址：

| 地址类型         | 二进制前缀 | 描述                                         |
| ---------------- | ---------- | -------------------------------------------- |
| 未指明地址       | ::/128     | 只有这台主机没有一个IPv6地址才可以作为源地址 |
| 环回地址         | ::1/128    | 和IPv4的环回地址一样                         |
| 多播地址         | FF00::/8   | 和IPv4的多播地址一样                         |
| 本地链路单播地址 | FE80::/10  | 本地IPv6地址，局域网                         |
| 全球单播地址     | 其他       | 可以划分如下                                 |

![4.6.2 IPv6](png/4.6.2 IPv6.png)

除此以外还有任播地址，意义是可以选择多个主机作为目的地址，但是只有一个才会被交付，一般是最近的一个。

### 从IPv4向IPv6过渡

由于直接认定某一天以后所有的协议都是IPv6是几乎不可能的，有太多的设备和软件甚至线路需要替换，因此只能采取逐步演进的方法，先设计一系列同时支持IPv4和IPv6的设备，然后等待IPv4的设备所剩无几的时候在强制替换成IPv6。从当下的情况来看，这样的形式至少要到2025年才可以完成过度，因此依旧有足够的时间。

当下采取的方案一般有两种。

+ 一个是双协议栈，即在发送v6数据报到路由器以后，进入v4网络之前，把需要的东西提取出来，重新打包成v4数据报，在进入v6的临界路由器处重新打包成v6格式。这样的处理会带来一个问题是某些字段无法恢复，这是因为设计的时候细节不一样导致的。
+ 一个是隧道技术，即直接把v6数据报作为v4的数据部分打包进去，在进入v6网时解包出来，这样的IPv4首部字段必须设计成41，以告知数据报的数据部分是v6数据报。

## IP多播

### IP多播的基本概念

再发送包的时候，如果目的地址有多个的话，则会有两种方式来完成这个目的：

+ 使用多个单播，这样可能会导致某一个路由器含有的报文太多。主要方式是生成和目的主机数量相同的报文，然后分别发送到路由器中，转发直到对面主机收到。
+ 使用一个多播，这样可以保证每一个路由器节点只会有一段相关的报文，但是有可能对方不支持这种操作。主要方式是每到一个路由器，首先分析多播的主机和路由表的匹配，然后计算出需要转发到多少个路由器中，之后复制对应的次数即可。

不过一定要注意的是，D类一般用于多播，IP数据报协议字段是2，表示使用的是IGMP协议。多播地址只能用于目的地址而不能用于源地址，而且不产生ICMP差错报文。

### 在局域网上进行硬件多播



### 网际组管理协议IGMP和多播路由选择协议

## 虚拟专用网VPN和网络地址转换NAT

### 虚拟专用网VPN

### 网络地址转换NT

## 多协议标记交换MPLS

### MPLS的工作原理

### MPLS首部的位置与格式
